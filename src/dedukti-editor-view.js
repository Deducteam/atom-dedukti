class DeduktiEditorView {

  constructor() {
    // DATA :
    this.FocusView = [];
    this.initialized = false;

  }

  getDefaultLocation() {
    // This location will be used if the user hasn't overridden it by dragging the item elsewhere.
    // Valid values are "left", "right", "bottom", and "center" (the default).
    return 'right';
  }

  getAllowedLocations() {
    // The locations into which the item can be moved.
    return ['right'];
  }

  initialize(){

    // Web page generated by the dom API

    // Create root element
    this.element = this.createCustomElement(
      "div",
      ["dedukti-editor"],
      [{ name: "id", value: "proofview" }],
      null,
      null
    );

    //First title
    this.proof = this.createCustomElement(
      "h2",
      ["highlight", "title-goals"],
      [],
      "Goals",
      this.element
    );

    //The List of unresolved goals
    this.list_of_proof = this.createCustomElement(
      "ol",
      ["goalstable"],
      [],
      null,
      this.element
    );

    //Second Title
    this.focus = this.createCustomElement(
      "h2",
      ["highlight", "title-focus"],
      [],
      "Focus",
      this.element
    );

    //List of Hypothesis :
    this.list_of_hypothesis = this.createCustomElement(
      "table",
      ["list_of_hypothesis"],
      [{ name: "align", value: "center" }],
      null,
      this.element
    );

    //bar
    this.bar = this.createCustomElement(
      "hr",
      ["bar-proof"],
      [],
      null,
      this.element
    );

    //Current objective
    this.current_objective = this.createCustomElement(
      "h3",
      ["proof-objectif", "text-highlight"],
      [],
      "Exemple d'objectif courant",
      this.element
    );

    //Button toolbar at the buttom of the page :
    this.div_button = this.createCustomElement(
      "div",
      ["btn-toolbar", "proof-button"],
      [{name : "align", value:"center"}],
      null,
      this.element
    );

    //First goup of buttons :
    this.div_button_first = this.createCustomElement(
      "div",
      ["btn-group","proof-button"],
      [],
      null,
      this.div_button
    );

    // Buttons :

    this.but3 = this.createCustomElement(
      "button",
      ["btn"],
      [{ name: "id", value: "third" }],
      "Previous Step",
      this.div_button_first
    );

    this.but2 = this.createCustomElement(
      "button",
      ["btn"],
      [{ name: "id", value: "second" }],
      "Next Step",
      this.div_button_first
    );


    // We consider that the view is now initialized
    this.initialized = true;
  }

  isInitialized(){ // This function is used to check if the basic elements of the view are created
    return this.initialized;
  }

  /* This function help us creating the element we need on our web page */
  createCustomElement(type, classlist, attributes, textcontent, parentnode) {

    //It is just of wrapper around the DOM API to clean the code.
    let element = document.createElement(type);
    let i;

    for (i = 0; i < classlist.length; i++) {
      element.classList.add(classlist[i]);
    }

    for (i = 0; i < attributes.length; i++) {
      element.setAttribute(attributes[i].name, attributes[i].value);
    }

    if (textcontent != null) {
      element.textContent = textcontent;
    }

    if (parentnode != null) {
      parentnode.appendChild(element);
    }

    return element;
  }

  /* A couple of basic functions to handle the view */
  getElement() {
    return this.element;
  }

  getTitle() {
    // Title of the Information Panel
    return "Proof Assistant";
  }

  getURI() {
    // Title of the Information Panel
    return "atom://dedukti-editor-info";
  }

  // Returns an object that can be retrieved when package is activated
  serialize() {}

  // Tear down any state and detach
  destroy() {
    this.element.remove();
  }

  /* We get the data from diagnostics for the moment */
  updateDiagnostics(data, text_editor_path) {
    this.FocusView = []; // We forget every diagnostics sent before by the server.
    let i;

    for (i = 0; i < data.length; i++) {
      if (data[i].goal_info != null) { // We get the hypothesis and the goal if there is something to display
        let j=0;
        // We define the variables we need
        let curentobj = "";
        let hypothesislist = [];
        let goallist = [];

        for(j=0;j<data[i].goal_info.goals.length;j++){ // for each diagnostics, we are looking for the main goal
          if(  data[i].goal_info.focus === data[i].goal_info.goals[j].gid ){
            curentobj      = data[i].goal_info.goals[j].type; //we take from the main goal and his hypothesis and his type
            hypothesislist = data[i].goal_info.goals[j].hyps;
          }
          goallist.push(data[i].goal_info.goals[j].type); //in any case, we add the goal in the goalslist
        }

        this.FocusView.push({ // we register within our memory
          path: text_editor_path,     // the file path
          range: data[i].range,       // the range to attribuate to this view
          goal: curentobj,            // the current goal
          hypothesis: hypothesislist,  // the list of hypothesis
          goals : goallist            // the list of unresolved goals
        });
      }
    }

  }

  // A function to update the focus part of the view when it's needed
  updateView(selection, editor) {
    let path = editor.getPath();
    let i = 0;
    // We check the selection is actually a point
    //We use selection because for the moment we think it' better to not update the view when the user select a large part of text
    if (
      selection.newScreenRange.start.row == selection.newScreenRange.end.row &&
      selection.newScreenRange.start.column ==
        selection.newScreenRange.end.column
    ) {
      // we create some alias to clean the code
      let row = selection.newScreenRange.start.row;
      let column = selection.newScreenRange.start.column;
      let none_objective = 0; //If no FocusView is associated with the cursor position

      for (i = 0; i < this.FocusView.length; i++) {
        // we find the focusView associated with the cursor position
        if (
          this.rangewithin(
            this.FocusView[i].path,
            this.FocusView[i].range.start.line,
            this.FocusView[i].range.end.line,
            this.FocusView[i].range.start.character,
            this.FocusView[i].range.end.character,
            path,
            row,
            column
          )
        ) {
          // we display the information contained in the focusView.
          this.setCurrentObjectif(this.FocusView[i].goal);
          this.setHypothesis(this.FocusView[i].hypothesis);
          this.setGoals(this.FocusView[i].goals);
          this.markGoal(this.FocusView[i]);   // we want to provide some visual information to the user.
          none_objective = 1;                 // We can now consider that we found a data within our tab that correspond to the situation
        }
      }
      if (none_objective === 0) {
        //If no FocusView is associated with the cursor position
        this.setCurrentObjectif(""); // The currentObjective is set to null.
        this.cleanHypothesis(); //We clean every hypothesis.
        this.cleanGoals(); //We clean every goals.
      }
    }
  }

  /* A couple of function tu update each part of the view */

  //update the current objective
  setCurrentObjectif(current) {
    this.current_objective.innerText = current;
  }

  //update the hypothesis list
  setHypothesis(hypothesis) {
    let i = 0;
    this.cleanHypothesis(); // We begin by erasing what was displayed before on the hypothesis list

    // Then, we display the hypothesis we want
    for (i = 0; i < hypothesis.length; i++) {
      let list_element = this.createCustomElement( // we begin by creating a tab
        "tr",                   //type
        ["focus_data"],         //classList
        [],                     //attributes
        null,                   // textContent
        this.list_of_hypothesis // parent node
      );

      let firstcol = this.createCustomElement(     // then the first column
        "td",
        ["hyponame"],
        [],
        hypothesis[i].hname, // we display in it the name
        list_element
      );

      let secondcol = this.createCustomElement(   // then the second column
        "td",
        ["hypodot"],
        [],
        " : ", // we display in it a small separator
        list_element
      );

      let thirdcol = this.createCustomElement(  // then the second column
        "td",
        ["hypotype"],
        [],
        hypothesis[i].htype, // we display in it the type
        list_element
      );


    }
  }

  //update the goals list
  setGoals(goallist, editor) {
    this.cleanGoals(); // We begin by erasing what was displayed before on the goals list
    let i = 0;

    for (i = 0; i < goallist.length; i++) { // for each goal, we add an element in the list
      let line = this.createCustomElement(
        "li",                 //type
        ["goallistelement"],  //classList
        [],                   //attributes
        goallist[i],          //textcontent
        this.list_of_proof    //parent node
      );
    }
  }

  /* A couple of functions to clean the view */
  cleanHypothesis() {
    while (this.list_of_hypothesis.firstChild) {
      this.list_of_hypothesis.removeChild(this.list_of_hypothesis.firstChild);
    }
  }

  cleanGoals() {
    while (this.list_of_proof.firstChild) {
      this.list_of_proof.removeChild(this.list_of_proof.firstChild);
    }
  }

  /* A couple of function to enhance the user experience */

  //The aim of this function is to help the user finding which part of the goals list is related to the focus.
  markGoal(dataview) {

    let goals = this.list_of_proof.getElementsByClassName("goallistelement"); // we find every element currently in the goalslist

    let i = 0;

    for(i=0; i < goals.length;i++) { //for ecah of those elements
      if(goals[i].textContent === dataview.goal){ //we vheck if it type is the same as the current goal
        goals[i].classList.add("text-info"); //if yes, we higlight it
      }
      else if (goals[i].classList.contains("text-info")){ //if no, we remove the higlighting if necessary
        goals[i].classList.remove("text-info");
      }
    }
  }

  /* Two function to handle key binding */
  nextFocus() {
    //All variables we need
    let editor = atom.workspace.getActiveTextEditor();
    let cursor = editor.getCursorScreenPosition();
    let path = editor.getPath();
    //This function return the closest next focus view to our current cursor.
    let point = this.closestNextRange(path, cursor.row, cursor.column);

    if (point != null) {
      //We check a next focus view actually exists.
      editor.setCursorScreenPosition([point.line, point.character]); //We move the cursor
    }
  }

  lastFocus() {
    //Same as nextFocus
    let editor = atom.workspace.getActiveTextEditor();
    let cursor = editor.getCursorScreenPosition();
    let path = editor.getPath();
    let point = this.closestLastRange(path, cursor.row, cursor.column);

    if (point != null) {
      editor.setCursorScreenPosition([point.line, point.character]);
    }
  }

  /* A couple of functions to deal with ranges */
  rangewithin(dvpath, dvRS, dvRE, dvCS, dvCE, apath, aR, aC) {
    /*This function  return a boolean, his value is true when the cursor symbolised by aRow (aR) and aColumn (aC) is within the range
    defined by the dvRowStart, dvRowEnd, dvColumnStart and dvColumnEnd. (and of course on the same file)
    */
    if (dvpath != apath) {
      return false;
    }
    if (dvRS > aR) {
      return false;
    }
    if (dvRE < aR) {
      return false;
    }
    if (dvRS === aR && dvCS > aC) {
      return false;
    }
    if (dvRE === aR && dvCE < aC) {
      return false;
    }

    return true;
  }

  closestLastRange(path, row, column) {
    let i;
    let candidate = [];
    let min;
    let min_index;

    //We compute the distance between each FocusView and the cursor, then we gather the results in an array called candidate
    for (i = 0; i < this.FocusView.length; i++) {
      if (this.FocusView[i].path === path) {
        if (this.FocusView[i].range.end.line < row) { // we check is is efficient to compute distance between the two
          let travel = row - this.FocusView[i].range.end.line;
          candidate.push({
            distance: travel,
            index: i
          });
        } else if (this.FocusView[i].range.end.line === row) {
          if (this.FocusView[i].range.end.character < column) {
            let travel = (column - this.FocusView[i].range.end.character) / 10;
            candidate.push({
              distance: travel,
              index: i
            });
          }
        }
      }
    }
    //We return the smallest distance
    if (candidate.length > 0) {
      min = candidate[0].distance;
      min_index = candidate[0].index;
      for (i = 1; i < candidate.length; i++) {
        if (candidate[i].distance < min) {
          min = candidate[i].distance;
          min_index = candidate[i].index;
        }
      }
      return this.FocusView[min_index].range.end;
    }
    //IN case there is no next FocusView
    return null;
  }

  //Exactely the same as closestLastRange except some details
  closestNextRange(path, row, column) {
    let i;
    let candidate = [];
    let min;
    let min_index;

    for (i = 0; i < this.FocusView.length; i++) {
      if (this.FocusView[i].path === path) {
        if (this.FocusView[i].range.start.line > row) {
          let travel = this.FocusView[i].range.start.line - row;
          candidate.push({
            distance: travel,
            index: i
          });
        } else if (this.FocusView[i].range.start.line === row) {
          if (this.FocusView[i].range.start.character > column) {
            let travel =
              (this.FocusView[i].range.start.character - column) / 10;
            candidate.push({
              distance: travel,
              index: i
            });
          }
        }
      }
    }

    if (candidate.length > 0) {
      min = candidate[0].distance;
      min_index = candidate[0].index;
      for (i = 1; i < candidate.length; i++) {
        if (candidate[i].distance < min) {
          min = candidate[i].distance;
          min_index = candidate[i].index;
        }
      }
      return this.FocusView[min_index].range.end;
    }

    return null;
  }

}

exports.default = DeduktiEditorView;
